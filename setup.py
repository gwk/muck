# Dedicated to the public domain under CC0: https://creativecommons.org/publicdomain/zero/1.0/.


import sys
from distutils import log
from distutils.dep_util import newer_group
from distutils.command.build_scripts import build_scripts  # type: ignore
from os import chmod, listdir as list_dir, mkdir as make_dir, makedirs as make_dirs
from os.path import (dirname as path_dir, exists as path_exists, isdir as is_dir, join as path_join, normpath as norm_path,
  splitext as split_ext)

from setuptools import Command, Extension, setup # type: ignore
from setuptools.command.build_ext import build_ext # type: ignore
from setuptools.command.develop import develop  # type: ignore
from setuptools.command.install import install  # type: ignore
from setuptools.command.install_scripts import install_scripts  # type: ignore
from setuptools.config import read_configuration  # type: ignore

from typing import Any

if sys.version_info < (3, 7): exit('error: muck requires Python3.7 or later. Make sure to install with `pip3` or `pip3.X`.')


base_dir = path_dir(norm_path(__file__)) or '.' # When run from pip, this is a temp dir.
assert not base_dir.endswith('/'), base_dir
base_dir += '/'

package_name = 'muck'
package_dir = path_join(base_dir, package_name)
bin_src_dir = path_join(package_dir, 'bin')


def msg(*items:Any) -> None: print(' ', *items)


class BuildExtLibmuck(build_ext): # type: ignore

  def build_extension(self, ext):
    '''
    Custom build process for libmuck.
    This appears to be necessary because on macOS at least the standard `build_extension` outputs a shared lib
    that dyld does not recognize as a dylib.
    I do not understand what format is actually output, only that the `-dynamiclib` flag is missing,
    and that simply adding that flag to the Extension constructor results in a clang error.

    Arguably we should be using some other install process because libmuck is not a real Python extension,
    but I do not see a better alternative:
    * `build_clib` produces a static library, and thus does not help us install and locate the shared lib.
    * `data_files` does not help with the compilation step, and MANIFEST.in adds poorly documented complications.

    The normal build process is two-phase compile and link; for convenience we do a single step.
    This might be a problem if the host requires a separate linker.
    We could instead leave the compile step alone and just override the link step,
    but doing so gets further into distutils internals.
    '''

    assert ext.name == 'muck._libmuck', ext
    sources = list(ext.sources)
    ext_path = self.get_ext_fullpath(ext.name)

    # Copied from distutils.command.build_ext:build_extension.
    if not (self.force or newer_group(sources, ext_path, 'newer')):
      log.debug("skipping '%s' extension (up-to-date)", ext.name)
      return
    else:
      log.info("building '%s' extension", ext.name)

    compiler = self.compiler
    # Copied from distutils.unixccompiler:_compile.
    compiler_so = compiler.compiler_so
    if sys.platform == 'darwin':
      import _osx_support # type: ignore
      compiler_so = _osx_support.compiler_fixup(compiler_so, cc_args=[])
    make_dirs(path_dir(ext_path), exist_ok=True) # Necessary as of 3.6, 3.7a3.
    cmd = [*compiler_so, *sources,
      '-g', '-fno-omit-frame-pointer',
      '-dynamiclib', '-o', ext_path]
    self.spawn(cmd)


class BuildScripts(build_scripts): # type: ignore
  def run(self) -> None:
    super().run()


class Develop(develop): # type: ignore
  def run(self) -> None:
    super().run()
    install_bins(dst_dir=self.script_dir)


class Install(install): # type: ignore
  def run(self) -> None:
    super().run()


class InstallScripts(install_scripts): # type: ignore
  def run(self) -> None:
    msg('InstallScripts')
    super().run()
    install_bins(dst_dir=self.install_dir)


def install_bins(dst_dir:str) -> None:
  '''
  Generate executable script entry points.
  We do this because standard entry_points/console_scripts have noticeably slow startup times,
  apparently due to overly complex boilerplate.
  '''
  msg('bin_src_dir:', bin_src_dir)
  msg('bin dst_dir:', dst_dir)

  if not is_dir(bin_src_dir):
    msg('note: no bin directory.')
    return
  if not path_exists(dst_dir): make_dir(dst_dir)
  py_path = path_join(dst_dir, 'python3')

  for name in list_dir(bin_src_dir):
    stem, ext = split_ext(name)
    if ext != '.py' or stem.startswith('.') or stem.startswith('_'): continue
    path = path_join(dst_dir, stem.replace('_', '-')) # Omit extension from bin name and use dashes.
    module = f'{package_name}.bin.{stem}'
    msg(f'generating script: {path}')
    with open(path, 'w') as f:
      f.write(bin_template.format(py_path=py_path, module=module))
      chmod(f.fileno(), 0o755)


bin_template = '''\
#!{py_path}
# Generated by muck/setup.py.
from {module} import main
main()
'''


setup(
  python_requires='>=3.7',
  ext_modules=[Extension('muck._libmuck', sources=['muck/libmuck.c'])],
  cmdclass={
    'build_ext': BuildExtLibmuck,
    'build_scripts': BuildScripts,
    'develop': Develop,
    'install': Install,
    'install_scripts': InstallScripts,
  },
)
